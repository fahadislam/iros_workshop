%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8

\documentclass[letterpaper, 10 pt, conference]{ieeeconf}  % Comment this line out if you need a4paper

%\documentclass[a4paper, 10pt, conference]{ieeeconf}      % Use this line for a4 paper

\IEEEoverridecommandlockouts                              % This command is only needed if 
                                                          % you want to use the \thanks command

\overrideIEEEmargins                                      % Needed to meet printer requirements.

%In case you encounter the following error:
%Error 1010 The PDF file may be corrupt (unable to open PDF file) OR
%Error 1000 An error occurred while parsing a contents stream. Unable to analyze the PDF file.
%This is a known problem with pdfLaTeX conversion filter. The file cannot be opened with acrobat reader
%Please use one of the alternatives below to circumvent this error by uncommenting one or the other
%\pdfobjcompresslevel=0
%\pdfminorversion=4

% See the \addtolength command later in the file to balance the column lengths
% on the last page of the document

\usepackage[bookmarks=true]{hyperref}
\usepackage{graphicx}
\usepackage[font=footnotesize]{subcaption}
\usepackage[font=footnotesize]{caption}
\usepackage{hyperref}
\usepackage{url}
\usepackage{amsmath,amssymb,amsfonts,amsfonts}
% \usepackage{algorithm}
% \usepackage[noend]{algorithmic}
\usepackage{xspace}
\usepackage{wrapfig}
\usepackage{color}

\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage[noend]{algpseudocode}
\usepackage{algpseudocode}

\title{\LARGE \bf
Provable Real-Time Planning for Repetitive Tasks
}


% \author{Albert Author$^{1}$ and Bernard D. Researcher$^{2}$% <-this % stops a space
% \thanks{*This work was not supported by any organization}% <-this % stops a space
% \thanks{$^{1}$Albert Author is with Faculty of Electrical Engineering, Mathematics and Computer Science,
%         University of Twente, 7500 AE Enschede, The Netherlands
%         {\tt\small albert.author@papercept.net}}%
% \thanks{$^{2}$Bernard D. Researcheris with the Department of Electrical Engineering, Wright State University,
%         Dayton, OH 45435, USA
%         {\tt\small b.d.researcher@ieee.org}}%
% }

\author{
Fahad Islam,
Oren Salzman {\normalfont and}
Maxim Likhachev
\\
The Robotics Institute, Carnegie Mellon University\\
%
\{fi,osalzman\}@andrew.cmu.edu,
maxim@cs.cmu.edu
}

\begin{document}



\maketitle
\thispagestyle{empty}
\pagestyle{empty}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}

This electronic document is a ÒliveÓ template. The various components of your paper [title, text, heads, etc.] are already defined on the style sheet, as illustrated by the portions given in this document.

\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{INTRODUCTION}
%1. What is the problem?
Consider the problem of a robot picking up objects from a conveyor belt and placing them into bins (see Fig.~\ref{fig:PR2}).
Similarly, consider a robot given the task of stock replenishment---moving in a supermarket and loading items from a cart it carries to half-empty shelves.
%2. Why is it relevant?
These problems are examples of repetitive tasks performed by (possibly highly articulated) robots in static environments where the start and target of each repetitive task is similar, yet not identical, to previous tasks.
Difference in the exact start and target position may be due to uncertainty in the environment (objects placed on different parts of the conveyor belt or in different orientation) or due to highly-similar tasks (objects placed in similar positions on a shelf).

%3. Why is it hard?
As the set of possible start and target locations may be large, caching pre-computed paths for all these queries in advance is unmanageable. 
Clearly, once a task is presented to the robot, it can compute a desired path online.
However, this may incur large online planning times that may be unacceptable in many settings.
For example, in our conveyor-belt setting, reducing the planning time immediately corresponds to faster unloading capabilities. 
Thus, a natural approach is to preprocess the environment in an offline phase to allow for fast planning times online.

%4. What have others done?
A natural approach to preprocess the environment is using the \textsf{PRM} algorithm~\cite{kavraki1996probabilistic}.
Once a a dense roadmap has been pre-computed, any query can be efficiently answered online by connecting the source and target to the roadmap. 
Query times can be significantly sped up by further preprocessing the roadmaps using landmarks~\cite{paden2017landmark}
Unfortunately, there is no guarantee that the a query can be connected to the roadmap as \textsf{PRM} only provides \emph{asymptotic} guarantees~\cite{KKL98}.
Furthermore, this connecting phase requires running a collision-detection algorithm which is typically considered the computational bottleneck in many motion-planning algorithms~\cite{L06}.

Recently, Lehner and  Albu{-}Sch{\"{a}}ffer~\cite{LA18} suggest the repetition roadmap to extend the \textsf{PRM} for the case of multiple highly-similar scenarios.
While there approach exhibits significant speedup in computation time, it still suffers from the previously-mentioned shortcomings.

A complementary approach to aggressively preprocess a given scenario is by minimizing collision-detection time.
However this requires designing robot-specific
circuitry~\cite{MFQSK16}
or limiting the approach to standard manipulators~\cite{YMILV18}.

An alternative approach is to precompute a set of complete paths into a library and given a query, attempt to match complete paths
from the library to the new query~\cite{berenson2012robot, jetchev2013fast}
%5. What's missing?

%6. What is our ONE key insight?
Our key insight is to combine a precomputed library~$\mathcal{L}$ of paths between \emph{several} start and target configurations together with a method to connect \emph{any} start and target configuration to a path in~$\mathcal{L}$ \emph{without} having to perform collision detection.
This insight allows us to provide \emph{provable bounds } on the time to solve motion-planning queries which are in the order of milliseconds for a seven DoF manipulator.

%7. How do we compare against the state of the art?
We evaluate our approach in simulation on the PR2 robot\footnote{http://www.willowgarage.com/pages/pr2/overview} (see Fig.~\ref{fig:PR2})
and show
{\color{blue} what do we show?}
%8. What are our contributions?
%9. What are our limitations?



% This template provides authors with most of the formatting specifications needed for preparing electronic versions of their papers. All standard paper components have been specified for three reasons: (1) ease of use when formatting individual papers, (2) automatic compliance to electronic requirements that facilitate the concurrent or later production of electronic products, and (3) conformity of style throughout a conference proceedings. Margins, column widths, line spacing, and type styles are built-in; examples of the type styles are provided throughout this document and are identified in italic type, within parentheses, following the example. Some components, such as multi-leveled equations, graphics, and tables are not prescribed, although the various table text styles are provided. The formatter will need to create these components, incorporating the applicable criteria that follow.

\section{Algorithm Description}

\subsection{Problem Formulation and Assumptions}
We propose a multi-query motion planning algorithm which is well suited for the planning problems that are highly repetitive. More formally our framework makes the following assumptions about the nature of the planning problems.
\begin{enumerate}
  \item The start configuration $s_{start}$ of the robot is fixed.
  \item The goal configuration $s_{goal}$ falls within a goal $\textit{region}$ $G$, which is a relatively small subset of the full configuration space of the robot. $G$ is defined as a region around some nominal goal configuration.
  \item A considerable amount of preprocessing time is provided.
  \item During the query phase the environment remains static. 
  \item We have access to a $\textit{weakly monotonic}$ heuristic function $h(s)$ defined as 

  \begin{center}
  $h(s) \geq \min\limits_{\forall s' \in Succs(s)} h(s') \quad \forall s,s' \in G \wedge s \neq s_{goal}$ 
  \end{center}
  Namely, for any state $s$ in $G$ except $s_{goal}$ one of its successors (also belonging to $G$) must have a heuristic value less than or equal to its heuristic value. This property should hold considering that all the edges in $G$ are traversable i.e. they have finite costs.
  % $G$ is defined as a 6-dimensional window around some nominal goal pose in the task space, $q = (\textit{x, y, z, roll, pitch, yaw})$.
\end{enumerate}

With these assumptions on the planning queries, we establish strong theoretical properties on the planning efficiency.

\subsection{Key Idea}
The planner comprises of a preprocessing and a query phase. In the preprocessing phase, $G$ is decomposed into subregions $R_i$ centered around what we call the $attractor$ states $s_{attractor_i}$ and radii $r_i$, where $i$ = 1 to $n$. These regions are constructed in such a way that
\begin{enumerate}
  \item For an goal state $s_{goal} \in R_i$, a pure greedy search with respect to the heuristic function $h(s, s_{attractor_i})$ will find a path to $s_{attractor_i}$ without getting stuck in local minima.
  \item The union of all the subregions completely cover $G$ so that any query state $s_{goal} \in G$ falls in one of the subregions.
\end{enumerate}

For all the attractor states we precompute paths from $s_{start}$ in the preprocessing phase. In the query phase, for a query $s_{goal}$, we identify which region it belongs to by using the radii of the subregions $r_i$, run a greedy search towards the corresponding attractor state to find a path to it, and finally stitch this path segment with the precomputed path to $s_{start}$ to get the complete plan.

\subsection{Preprocessing Phase}
The preprocessing phase is detailed in Alg.~\ref{alg:1}. The algorithm takes in the specification of the goal region and the start state as an input and outputs the subregions specified by an attractor state and a radius and the computed paths from each of the attractors to the start state. The way these radii are computed is explained in Alg.~\ref{alg:2}. This preprocessed information is all what is used in the query phase. $G$ is centered around some nominal goal state (assumed to be valid) which is used as the attractor for the first region. The algorithm maintains a set each for valid and invalid frontier states (lines~\ref{alg:1:v} and~\ref{alg:1:i}). Each time a subregion is computed (line~\ref{alg:1:cr}), the frontier states are populated into $V$ and $I$ (lines~\ref{alg:1:insert_v} and~\ref{alg:1:insert_i}) after checking the state validity which typically implies running a collision checker. After the first region is computed, a state from $V$ is popped and used as the attractor for the next region. Note that an attractor gets discarded if it is already covered by an existing region. Once $V$ gets empty the algorithm starts to search for valid and uncovered states by growing regions around the states popped from the invalid set $I$. If a valid and uncovered state is found it is added to $V$ and the algorithm goes back to computing subregions, otherwise if $I$ also gets empty the algorithm terminates and at this point it is guaranteed that each valid state contained in $G$ is covered under atleast one subregion.

\begin{algorithm}
\footnotesize
\hspace*{\algorithmicindent} \textbf{Inputs:} $G$, $s_{start}$   \Comment{goal region specification and start state} \\
\hspace*{\algorithmicindent} \textbf{Outputs:} $R_i$, $\pi_i$ where i = 1 to $n$,    \Comment{subregions and paths to $s_{start}$} \\
\hspace*{\algorithmicindent} \textbf{Parameters:} $r_{max}$   \Comment{maximum radius of a region}
\caption{Goal Region Preprocessing}\label{alg:1}
\begin{algorithmic}[1]
\Procedure{PreprocessRegion}{$G, r_{max}$}
  \State $V$ = $\phi$   \Comment{list of valid frontier states} \label{alg:1:v}
  \State $I$ = $\phi$   \Comment{list of invalid frontier states} \label{alg:1:i}
  \State $s_g$ $\leftarrow$ GetNominalGoal($G$)
    \State Insert $s_g$ in $V$
    \While {$V$ and $I$ are not empty}
        \While {$V$ is not empty}
          \State $s_{attractor_i}$ $\leftarrow$ $V.pop()$
            \If {$s_{attractor_i}$ is not covered}
                \State $(Open, r)$ $\leftarrow$ ComputeReachability($s_{attractor_i}, r_{max}$) \label{alg:1:cr}
                \State insert Valid($Open$) in $V$  \label{alg:1:insert_v}
                \State insert Invalid($Open$) in $I$   \label{alg:1:insert_i}
                \State $R_i$ $\leftarrow$ $(s_{attractor_i}, r_i)$
            \EndIf
        \EndWhile
        \While {$I$ is not empty}
            \State $s$ $\leftarrow$ $I.pop()$
          \If {$s_{attractor_i}$ is not covered}
                \State $(X, r)$ $\leftarrow$ SearchValidUncoveredStates($s, r_{max}$)
                \State $\hat{R}_i$ $\leftarrow$ $(r,s)$ \Comment{invalid region}
                \If {$X$ is not empty}  \Comment{no valid state found}
                    \State insert $X$ in $V$
                    \State break
                \EndIf
            \EndIf
        \EndWhile
    \EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsubsection{Reachability Search}
The core of our planner lies in the way we compute the subregions (Alg.~\ref{alg:2}). The algorithm maintains a list of $greedy$ states. A s

\begin{algorithm}
\footnotesize
\caption{Reachability Search}\label{alg:2}
\begin{algorithmic}[1]
\Procedure{ComputeReachability}{$s_{attractor_i}, r_{max}$}
\State $Greedy \leftarrow \{s_{attractor_i}\}$ \Comment{Greedy set}
\State $Open \leftarrow \{$Preds($s_{attractor_i}$)$\}$  \Comment{priority: min $h(s,s_{attractor_i})$ value}
\State $r_i \leftarrow 0$

\While {$r_i \leq r_{max}$}
    \State $s \leftarrow$ $Open$.pop()
    \State $s'_g \leftarrow$ GreedySucc($s$)  \Comment{acc. to some tie breaking criteria}
    \If {$s'_g$ $\in$ $Greedy$ and Valid(edge(s,$s'_g$))}
        \State $Greedy \leftarrow Greedy \cup s$  \Comment{$s$ is greedy}
    \ElsIf {Valid(s)}
        \State break
    \EndIf
    \State $r_i \leftarrow h(s, s_{attractor_i})$
    \For {each $p \in Preds($s$)$}
        \If {$p \notin Greedy$}    \Comment{avoid reevaluation}
            \State Insert $p$ in $Open$ with priority $h(p, s_{attractor_i})$
        \EndIf
    \EndFor
\EndWhile
\State return $r_i$

\EndProcedure
\end{algorithmic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{plain}
\bibliography{references}

\end{document}
