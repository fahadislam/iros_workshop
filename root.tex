%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8

\documentclass[letterpaper, 10 pt, conference]{ieeeconf}  % Comment this line out if you need a4paper

%\documentclass[a4paper, 10pt, conference]{ieeeconf}      % Use this line for a4 paper

\IEEEoverridecommandlockouts                              % This command is only needed if 
                                                          % you want to use the \thanks command

\overrideIEEEmargins                                      % Needed to meet printer requirements.

%In case you encounter the following error:
%Error 1010 The PDF file may be corrupt (unable to open PDF file) OR
%Error 1000 An error occurred while parsing a contents stream. Unable to analyze the PDF file.
%This is a known problem with pdfLaTeX conversion filter. The file cannot be opened with acrobat reader
%Please use one of the alternatives below to circumvent this error by uncommenting one or the other
%\pdfobjcompresslevel=0
%\pdfminorversion=4

% See the \addtolength command later in the file to balance the column lengths
% on the last page of the document

\usepackage[bookmarks=true]{hyperref}
\usepackage{graphicx}
\usepackage[font=footnotesize]{subcaption}
\usepackage[font=footnotesize]{caption}
\usepackage{hyperref}
\usepackage{url}
\usepackage{amsmath,amssymb,amsfonts,amsfonts}
% \usepackage{algorithm}
% \usepackage[noend]{algorithmic}
\usepackage{xspace}
\usepackage{wrapfig}
\usepackage{color}

\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage[noend]{algpseudocode}
\usepackage{algpseudocode}


\newcommand{\calX}{\ensuremath{\mathcal{X}}\xspace}
\newcommand{\calL}{\ensuremath{\mathcal{L}}\xspace}
\newcommand{\calS}{\ensuremath{\mathcal{S}}\xspace}
\newcommand{\sAttract}{\ensuremath{s^{\text{attractor}}_i}\xspace}
\newcommand{\sStart}{\ensuremath{s_{\text{start}}\xspace}}
\newcommand{\sGoal}{\ensuremath{s_{\text{goal}}\xspace}}
\newcommand{\sNom}{\ensuremath{s_{\text{nominal}}\xspace}}


\title{\LARGE \bf
Provable Real-Time Planning for Repetitive Tasks
}


% \author{Albert Author$^{1}$ and Bernard D. Researcher$^{2}$% <-this % stops a space
% \thanks{*This work was not supported by any organization}% <-this % stops a space
% \thanks{$^{1}$Albert Author is with Faculty of Electrical Engineering, Mathematics and Computer Science,
%         University of Twente, 7500 AE Enschede, The Netherlands
%         {\tt\small albert.author@papercept.net}}%
% \thanks{$^{2}$Bernard D. Researcheris with the Department of Electrical Engineering, Wright State University,
%         Dayton, OH 45435, USA
%         {\tt\small b.d.researcher@ieee.org}}%
% }

\author{
Fahad Islam,
Oren Salzman {\normalfont and}
Maxim Likhachev
\\
The Robotics Institute, Carnegie Mellon University\\
%
\{fi,osalzman\}@andrew.cmu.edu,
maxim@cs.cmu.edu
}

\begin{document}



\maketitle
\thispagestyle{empty}
\pagestyle{empty}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}

This electronic document is a ÒliveÓ template. The various components of your paper [title, text, heads, etc.] are already defined on the style sheet, as illustrated by the portions given in this document.

\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%1. What is the problem?
Consider the problem of a robot picking up objects from a high-speed conveyor belt and placing them into bins (see Fig.~\ref{fig:PR2}).
Similarly, consider a robot given the task of stock replenishment---moving in a supermarket and loading items from a cart it carries to half-empty shelves.
%2. Why is it relevant?
These problems are examples of repetitive tasks performed by (possibly highly articulated) robots in static environments where the start and target of each repetitive task is similar, yet not identical, to previous tasks.
Difference in the exact start and target position may be due to uncertainty in the environment (objects placed on different parts of the conveyor belt or in different orientation) or due to highly-similar tasks (objects placed in similar positions on a shelf).

%3. Why is it hard?
As the set of possible start and target locations may be large, caching pre-computed paths for all these queries in advance is unmanageable. 
Clearly, once a task is presented to the robot, it can compute a desired path online.
However, this may incur large online planning times that may be unacceptable in many settings.
For example, in our conveyor-belt setting, reducing the planning time immediately corresponds to faster unloading capabilities. 
Moreover, if the planner cannot \emph{guarantee} to pick items from the conveyor in a timely manner, the system is required to account for missed items by e.g., additional conveyor belts that will redirect items back to the robot---a costly backup in terms of both time and space.
Thus, a natural approach is to preprocess the environment in an offline phase to allow for fast planning times online.

%4. What have others done?
One way to preprocess the environment is using the \textsf{PRM} algorithm~\cite{kavraki1996probabilistic}.
Once a a dense roadmap has been pre-computed, any query can be efficiently answered online by connecting the source and target to the roadmap. 
Query times can be significantly sped up by further preprocessing the roadmaps using landmarks~\cite{paden2017landmark}.
Unfortunately, there is no guarantee that the a query can be connected to the roadmap as \textsf{PRM} only provides \emph{asymptotic} guarantees~\cite{KKL98}.
Furthermore, this connecting phase requires running a collision-detection algorithm which is typically considered the computational bottleneck in many motion-planning algorithms~\cite{L06}.

Recently, Lehner and  Albu{-}Sch{\"{a}}ffer~\cite{LA18} suggest the repetition roadmap to extend the \textsf{PRM} for the case of multiple highly-similar scenarios.
While their approach exhibits significant speedup in computation time, it still suffers from the previously-mentioned shortcomings.

A complementary approach to aggressively preprocess a given scenario is by minimizing collision-detection time.
However this requires designing robot-specific
circuitry~\cite{MFQSK16}
or limiting the approach to standard manipulators~\cite{YMILV18}.

An alternative approach is to precompute a set of complete paths into a library and given a query, attempt to match complete paths
from the library to the new query~\cite{berenson2012robot, jetchev2013fast}.
Unfortunately, this approach also cannot provide any of the guarantees required by our applications.

{\color{blue} Add refs to Tensal's work~\cite{UK17,UK18}. Possibly in Sec II.}
%5. What's missing?

%6. What is our ONE key insight?
Our key insight is to combine a precomputed library~$\calL$ of paths between \emph{several} start and target configurations together with a method to connect \emph{any} start and target configuration to a path in~$\calL$ \emph{without} having to perform collision detection.
This insight allows us to provide \emph{provable bounds } on the time to solve motion-planning queries which are in the order of milliseconds for a seven DoF manipulator.

%7. How do we compare against the state of the art?
We evaluate our approach in simulation on the PR2 robot\footnote{http://www.willowgarage.com/pages/pr2/overview} (see Fig.~\ref{fig:PR2})
and show
{\color{blue} what do we show?}
%8. What are our contributions?
%9. What are our limitations?



% This template provides authors with most of the formatting specifications needed for preparing electronic versions of their papers. All standard paper components have been specified for three reasons: (1) ease of use when formatting individual papers, (2) automatic compliance to electronic requirements that facilitate the concurrent or later production of electronic products, and (3) conformity of style throughout a conference proceedings. Margins, column widths, line spacing, and type styles are built-in; examples of the type styles are provided throughout this document and are identified in italic type, within parentheses, following the example. Some components, such as multi-leveled equations, graphics, and tables are not prescribed, although the various table text styles are provided. The formatter will need to create these components, incorporating the applicable criteria that follow.

\section{Algorithm Framework}
In this section we describe our algorithmic framework.
We start (Sec.~\ref{sec:pdef}) by formally defining our problem and continue...
\subsection{Problem Formulation and assumptions}
Let $\calX$ be the configuration space of a robot operating in a static environment.
We are given in advance a start configuration~$\sStart \in \calX$ and some goal region~$G \subset \calX$.
In the query phase we will be given a multiple queries $(\sStart, s_{\rm goal})$ where $s_{\rm goal} \in G$ and for each query, we need to compute a collision-free path connecting $\sStart$ to $s_{\rm goal}$.

We discretize $\calX$ into a state lattice $\calS$ such that any state $s \in \calS$ is connected to a set of successors via a mapping Succs: $\calS \rightarrow 2^\calS$ and make the following assumptions:

\begin{enumerate}
  \item[A1] The goal region~$G \subset \calX$ is a relatively small subset of the full configuration space of the robot. Namely, it is feasible to iterate over all states in $G$.
  
  \item[A2] The planner has access to a $\textit{weakly-monotonic}$ heuristic function $h: \calS \times \calS \rightarrow \mathbb{R}$ such that $\forall s_1, s_2  \in G$ where $s_1 \neq s_2$ it holds that,

  \begin{center}
    $h(s_1, s_2) \geq \min\limits_{\forall s_1' \in \text{Succs}(s_1)} h(s_1', s_2) \quad \forall s_1'\in G $. 
  \end{center}
  Namely, for any distinct pair of states ($s_1, s_2$) in $G$, atleast one of $s_1$'s successors (also belonging to $G$) must have a heuristic value less than or equal to its heuristic value. 
  This property should hold assuming that all the edges in $G$ are traversable i.e., they have finite costs.
  {\color{blue} I don't understand the last sentence}
  % $G$ is defined as a 6-dimensional window around some nominal goal pose in the task space, $q = (\textit{x, y, z, roll, pitch, yaw})$.
\end{enumerate}

These assumptions allow us to establish strong theoretical properties regarding the efficiency of our planner.

\subsection{Key Idea}
Our planner comprises of a preprocessing and a query phase. 
In the preprocessing phase, $G$ is decomposed into~$n$ (possibly overlapping) subregions $R_i$ (for $i \in [n]$).
Each subregion $R_i$ will be defined using a so-called ``attractor state''~
\sAttract and a radius $r_i$.
% centered around what we call the $attractor$ states $s_{attractor_i}$ and radii $r_i$, where $i$ = 1 to $n$. 
These regions are constructed in such a way that
\begin{enumerate}
  \item For any goal state $s_{\rm goal} \in R_i \cap G$, a greedy search with respect to $h(s, \sAttract)$ over $\calS$ starting at \sStart will result in a collision-free path to \sAttract.
  \item The union of all the subregions completely cover $G$. 
  		Namely, $\forall s \in \calL \cap G, \exists R_i \ s.t. \ s \in R_i$.
  		%In other words, any query state $\sGoal \in G$ will fall in atleast one of the subregions.
\end{enumerate}

In the preprocessing stage, we precompute a library of collision-free paths $\calL$ which includes one path from \sStart to each attractor state. 
In the query phase, given a query \sGoal, we 
(i)~identify a region $R_i$ such $\sGoal \in R_i$ (using the precomputed radii~$r_i$),
(ii)~run a greedy search towards~\sAttract using and
(iii)~append this path segment with the precomputed path in $\calL$ to \sStart  to obtain the complete plan.

\subsection {Algorithm}
\subsubsection{Preprocessing Phase}
The preprocessing phase of our algorithm, detailed in Alg.~\ref{alg:1}, takes as input the start state~$\sStart$ and the goal region~$G$ and outputs a set of subregions~$R_i$ specified by an attractor state \sAttract and a corresponding radius $r_i$ and the computed paths from each \sAttract to \sStart. 
The way these radii are computed is explained in Alg.~\ref{alg:2}. 
This preprocessed information is all what is used in the query phase. 
The goal region~$G$ is centered around some nominal goal state (assumed to be valid) which is used as the attractor for the first region. The algorithm maintains a set each for valid and invalid frontier states (lines~\ref{alg:1:v} and~\ref{alg:1:i}). Each time a subregion is computed (line~\ref{alg:1:cr}), the frontier states are populated into $V$ and $I$ (lines~\ref{alg:1:insert_v} and~\ref{alg:1:insert_i}) after checking the state validity which typically implies running a collision checker. After the first region is computed, a state from $V$ is popped and used as the attractor for the next region (line~\ref{alg:1:pop}). For every attractor, a path $\pi_i$ to the $s_{start}$ is also computed (line~\ref{alg:1:path}). Note that an attractor gets discarded if it is already covered by an existing region (line~\ref{alg:1:discard}). Once $V$ gets empty the algorithm starts to search for states which are valid and yet uncovered by growing regions around the states popped from the invalid set $I$ (lines ~\ref{alg:1:iv_loop} to ~\ref{alg:1:iv_region}). If a valid and uncovered state is found it is added to $V$ and the algorithm goes back to computing subregions (lines ~\ref{alg:1:x_states} to ~\ref{alg:1:break}), otherwise if $I$ also gets empty the algorithm terminates and at this point it is guaranteed that each valid state contained in $G$ is covered under atleast one subregion.

\begin{algorithm}
\footnotesize
\hspace*{\algorithmicindent} \textbf{Inputs:} $G$, $\sStart$   
\Comment{goal region and start state} \\
\hspace*{\algorithmicindent} \textbf{Outputs:} $R_i = (\sAttract, r_i)$, $\pi_i$,
\Comment{subregions and paths to $\sStart$} \\
\hspace*{\algorithmicindent} \textbf{Parameters:} $r_{\rm max}$   \Comment{maximum radius of a region}
\caption{Goal Region Preprocessing}\label{alg:1}
\begin{algorithmic}[1]
\Procedure{PreprocessRegion}{$G, r_{\rm max}$}
  \State $s \leftarrow$ SampleValidState($G$)  
  \State $V \leftarrow \{ s \}$   \Comment{valid frontier states initialized to a random state} \label{alg:1:v}
  \State $I$ = $\emptyset$   \Comment{invalid frontier states} \label{alg:1:i}
  \State $ i \leftarrow 0$
  
  \vspace{2mm}
    \While {$V$ and $I$ are not empty}
        \While {$V$ is not empty}
          \State $s \leftarrow V.\text{pop}()$ \label{alg:1:pop}
            \If {$\nexists R_i \ s.t. \ s \in R_i$ }  \label{alg:1:discard}
            \Comment{$s$ is not covered}
				\State $\sAttract \leftarrow s$                
                \State $\pi_i$ = PlanPath($\sAttract , \sStart$)  \label{alg:1:path}
                \State $(Open, r_i) \leftarrow$ ComputeReachability($\sAttract, r_{\rm max}$) \label{alg:1:cr}
                \State insert Valid($Open$) in $V$  \label{alg:1:insert_v}
                \State insert Invalid($Open$) in $I$   \label{alg:1:insert_i}
                \State $R_i$ $\leftarrow$ $(\sAttract, r_i)$; \hspace{2mm} $ i \leftarrow i+1$            \EndIf
        \EndWhile

\vspace{2mm}        
        
        \While {$I$ is not empty} \label{alg:1:iv_loop}
            \State $s$ $\leftarrow$ $I.pop()$
			\If {$\nexists R_i \ s.t. \ s \in R_i$ }      \Comment{$s$ is not covered}
                \State $(X, r)$ $\leftarrow$ SearchValidUncoveredStates($s, r_{\rm max}$)
                \State $\hat{R}_i$ $\leftarrow$ $(r,s)$ \Comment{invalid region}  \label{alg:1:iv_region}
                \If {$X$ is not empty}  \Comment{no valid state found}  \label{alg:1:x_states}
                    \State insert $X$ in $V$
                    \State break  \label{alg:1:break}
                \EndIf
            \EndIf
        \EndWhile
    \EndWhile

  \vspace{2mm}

    \Return $R_i$, $\pi_i$ for i = 1 to $n$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\paragraph*{Reachability Search}
The core of our planner lies in the way we compute the subregions (Alg.~\ref{alg:2}). We call it Reachability Search. The algorithm maintains a set of $reachable$ states $S_{reachable}$. The invariant that the reachable states maintain is that, the greedy successor of every reachable state is also a reachable state, except the attractor which is initially labelled as reachable (line~\ref{alg:2:reachable}).  The idea here is that running a greedy search from any reachable state in the subregion will only expand states along the path to the attractor state. The algorithm computes a subregion that covers the maximum number of reachable states that can fit into a hyper-ball and the measure for the radius of this hyper-ball is the heuristic function $h(s,s_{attractor_i})$. The search maintains a priority queue $Open$ with $h(s,s_{attractor_i})$ as the priority. Initially the predecessors of $s_{attractor_i}$ are inserted in the $Open$ (line~\ref{alg:2:open}). If for each expanded predecessor, its valid greedy successor is in $S_{reachable}$, then the predecessor is also labelled as reachable (lines~\ref{alg:2:crit} and~\ref{alg:2:set}). As the priorty used for $Open$ is the heuristic function, the radius of this hyper-ball keeps on increasing (line~\ref{alg:2:rad}). Now we could terminate the search as soon as we see the first non-reachable state (say a state entering an obstacle) but then it won't capture the maximum number of reachable states. Instead, we let the region grow through the invalid states and we terminate when the search pops a state which is valid but does not have a successor state in $S_{reachable}$ (line~\ref{alg:2:terminate}). Intuitively it corresponds to the condition when the reachability search exists an obstacle. At termination, all the states within the boundary of radius $r_i$ (excluding the boundary) are reachable.

\begin{algorithm}
\footnotesize
\caption{Reachability Search}\label{alg:2}
\begin{algorithmic}[1]
\Procedure{ComputeReachability}{$\sAttract, r_{\rm max}$}
\State $S_{reachable} \leftarrow \{\sAttract\}$ \Comment{Reachable set} \label{alg:2:reachable}
\State $Open \leftarrow \{$Preds($\sAttract$)$\}$  \Comment{priority: min $h(s,\sAttract)$} \label{alg:2:open}
\State $r_i \leftarrow 0$

\While {$r_i \leq r_{\rm max}$}
    \State $s \leftarrow$ $Open$.pop()
    \State $s'_g \leftarrow$ GreedySucc($s$)  \Comment{acc. to some tie breaking criteria}
    \If {$s'_g$ $\in$ $S_{reachable}$ and Valid(edge(s,$s'_g$))}  \label{alg:2:crit}
        \State $S_{reachable} \leftarrow S_{reachable} \cup s$  \Comment{$s$ is greedy} \label{alg:2:set}
    \ElsIf {Valid(s)} \label{alg:2:terminate}
        \State break
    \EndIf
    \State $r_i \leftarrow h(s, \sAttract)$ \label{alg:2:rad}
    \For {each $p \in Preds($s$)$}
        \If {$p \notin S_{reachable}$}    \Comment{avoid reevaluation}
            \State Insert $p$ in $Open$ with priority $h(p, \sAttract)$
        \EndIf
    \EndFor
\EndWhile
\State return $r_i$

\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsubsection{Query Phase}
Once the goal region $G$ is preprocessed, the query phase is straight forward. For any query goal state $s_{goal} \in G$, we lookup for any subregion $R_i$ which covers it. For a region $R_i$ to cover $s_{goal}$, the following condition should hold true.
\begin{center}
$h(s_{goal}, s_{attractor_i}) < r_i$
\end{center}

Then we run a greedy search starting from $s_{goal}$ by simply expanding the successors with the minimum heuriistic $h(s_{goal}, s_{attractor_i})$ values until the search reaches $s_{attractor_i}$. The traced path is then stitched to the precomputed path $\pi_i$, and to get the final path from the $s_{start}$ to $s_{goal}$. An important point to note here is that we don't even have to perform collision checking during the greedy search which makes the query phase even more time efficient.

\subsection {Theoretical Properties}
TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{plain}
\bibliography{references}

\end{document}
